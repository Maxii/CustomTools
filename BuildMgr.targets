<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="UnityTest" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

    <!-- For the Attrib task -->
    <Import Project="$(CommunityTasksDir)MSBuild.community.tasks.targets" />
    
    <!-- Clean - full clean of Included VS Projects and Unity's Code Library -->
    <PropertyGroup>
        <CleanDependsOn>
            $(CleanDependsOn);
            _CoreClean;
            _ProjectClean;
            _UnityClean;
        </CleanDependsOn>
    </PropertyGroup>
    <Target Name="Clean" DependsOnTargets="$(CleanDependsOn)" />
    <Target Name="_CoreClean" >        
        <!-- Clean Outputs in the CommonOutputDir -->
        <ItemGroup>
            <AllFilesInCommonOutputDir Include="$(CommonOutputDir)\%(AllConfigurations.Identity)\**\*" />
        </ItemGroup>
        <Attrib Files="@(AllFilesInCommonOutputDir)" ReadOnly="false" />
        <Delete Files="@(AllFilesInCommonOutputDir)" />
        <!-- TODO RemoveDir Directories="$(...)" -->
    </Target>
    <Target Name="_ProjectClean">
        <!-- Clean default project-specific outputs too as other Solution Builds can populate them -->
        <MSBuild Projects="@(IncludedProjectFiles)"
                 BuildInParallel="true"
                 Properties="Configuration=%(AllConfigurations.Identity)"
                 Targets="Clean">
        </MSBuild>
    </Target>
    <Target Name="_UnityClean">
        <!-- UNDONE Need to confirm Unity is not running as condition -->
        <!-- UNDONE Need to account for more than 1 Unity Project -->
        <ItemGroup>
            <AllFilesInUnityCodeLibrary Include="$(UnityCodeLibraryDir)\**\*" />
        </ItemGroup>
        <Attrib Files="@(AllFilesInUnityCodeLibrary)" ReadOnly="false" />
        <Delete Files="@(AllFilesInUnityCodeLibrary)" />
        <!-- TODO RemoveDir Directories="$(UnityCodeLibraryDir)" -->
    </Target>

    <!-- Build - incremental build of ALL included Projects -->
    <PropertyGroup>
        <BuildDependsOn>
            $(BuildDependsOn);
            BeforeBuild;
            _CoreBuild;
            AfterBuild;
        </BuildDependsOn>
    </PropertyGroup>
    <Target Name="Build" DependsOnTargets="$(BuildDependsOn)" />
    <Target Name="BeforeBuild" />
    <!-- _CoreBuild using Target batching to get incremental build behavior -->
    <Target Name="_CoreBuild" Inputs="@(IncludedProjectFiles)" Outputs="%(AllConfigurations.Identity)" >
        <MSBuild
        Projects="@(IncludedProjectFiles)"
        Targets="Build"
        Properties="OutputPath=$(CommonOutputDir)%(AllConfigurations.Identity); Configuration=%(AllConfigurations.Identity)" >
            <Output ItemName="BuildOutputs" TaskParameter="TargetOutputs" />
        </MSBuild>
        <!--<Message Text="Build Outputs: $(NewLine)@(BuildOutputs, '$(NewLine)')" Importance="high"/>-->
    </Target>
    <Target Name="AfterBuild" />

    <!-- Rebuild - full clean followed by a new VS Build of Code -->
    <PropertyGroup>
        <RebuildDependsOn>
            $(RebuildDependsOn);
            Clean;
            _IncrementAssemblyVersion;
            Build;
        </RebuildDependsOn>
    </PropertyGroup>
    <Target Name="Rebuild" DependsOnTargets="$(RebuildDependsOn)" />

    <!-- As a Rebuild of the AssemblyVersionInfo project generated from here currently doesn't generate 
    an increment of the version number (bug in Build Version Increment addin?), I need to manually Rebuild 
    that project before I Rebuild with this BuildMgr. -->
    <Target Name="_IncrementAssemblyVersion" >
        <ItemGroup>
            <AssyVersionInfoProject Include="$(CustomToolsDir)CustomTools.AssemblyVersionInfo\CustomTools.AssemblyVersionInfo.csproj" />
        </ItemGroup>
        <MSBuild Projects="@(AssyVersionInfoProject)"
                 Properties="Configuration=Release"
                 Targets="Rebuild" />
        <Warning Text="Auto Version Increment does not work. %0aDid you remember to increment the Assembly Version by rebuilding the AssemblyVersionInfo Project manually?" />
    </Target>

    <!-- Test - fills in any build gaps, then runs all Unit Tests -->
    <PropertyGroup>
        <TestDependsOn>
            $(TestDependsOn);
            Build;
        </TestDependsOn>
    </PropertyGroup>
    <Target Name="Test" DependsOnTargets="$(TestDependsOn)">
        <!-- TODO how to detect and call unit test projects -->
        <!-- TODO Need notification of success or failure -->
        <Message Text="Running Unit Tests which currently do nothing." Importance="high"/>
    </Target>

    <!-- CleanTest - cleans, builds and runs Unit Tests -->
    <PropertyGroup>
        <CleanTestDependsOn>
            $(CleanTestDependsOn);
            Rebuild;
            Test;
        </CleanTestDependsOn>
    </PropertyGroup>
    <Target Name="CleanTest" DependsOnTargets="$(CleanTestDependsOn)" />

    <!-- UnityTest - cleans, builds and sets up Unity for testing -->
    <PropertyGroup>
        <UnityTestDependsOn>
            $(UnityTestDependsOn);
            Rebuild;
            _CopyOutputToUnity;
            _GenerateMdbFiles;
            <!-- Unity .pdb files are automatically cleaned after .mdb files are generated -->
            _ConfirmDebugEnvReadiness;
            _LaunchUnity;
            _PromptMonoDebuggerLaunch;
        </UnityTestDependsOn>
    </PropertyGroup>
    <Target Name="UnityTest" DependsOnTargets="$(UnityTestDependsOn)" />

    <!-- Copy all Output files from the CommonOutputDir 'Release' to Unity's CodeLibrary -->
    <Target Name="_CopyOutputToUnity" > <!-- No need for incremental copy as Unity is cleaned before this task is called -->
        <ItemGroup>
            <OutputFilesToCopy Include="$(CommonOutputDir)Release\**\*" />
        </ItemGroup>
        <!-- If the Unity CodeLibrary directory doesn't exist then create it -->
        <MakeDir Directories="$(UnityCodeLibraryDir)" Condition="!Exists('$(UnityCodeLibraryDir)')"/>
        <Message Text="Output files copied to Unity Code Library: $(NewLine)@(OutputFilesToCopy, '$(NewLine)')" Importance="high"/>
        <Copy SourceFiles="@(OutputFilesToCopy)" DestinationFolder="$(UnityCodeLibraryDir)" OverwriteReadOnlyFiles="true" />
    </Target>

    <!-- Generate the .mdb debug file in Unity IFF the one that may already be there requires updating -->
    <Target Name="_GenerateMdbFiles" >
        <!-- No need for incremental approach as Unity is cleaned before this task is called -->
        <PropertyGroup>
            <!-- pdb2mdb.exe does not work if copied to \contrib folder -->
            <!-- <MdbGeneratorPath>$(ContribDir)MdbGenerator\pdb2mdb.exe</MdbGeneratorPath> -->
            <MdbGeneratorPath>C:\Program Files\Unity\Editor\Data\Mono\lib\mono\2.0\pdb2mdb.exe</MdbGeneratorPath>
        </PropertyGroup>
        <ItemGroup>
            <AllProjectAssembliesInUnity Include="$(UnityCodeLibraryDir)%(IncludedProjectFiles.Filename).dll" />
        </ItemGroup>
        <Message Text="AllProjectAssembliesInUnity: $(NewLine)@(AllProjectAssembliesInUnity, '$(NewLine)')" Importance="high"/>

        <!--" or the hex %22 are not needed around the parameter as long as there are no spaces -->
        <Exec WorkingDirectory="$(UnityCodeLibraryDir)" Command='"$(MdbGeneratorPath)" %(AllProjectAssembliesInUnity.Identity)' />
    </Target>
    
    <!-- Delete the .pdb files from Unity -->
    <Target Name="_CleanUnityPdbFiles" AfterTargets="_GenerateMdbFiles" >
        <ItemGroup>
            <PdbFilesToDelete Include="$(UnityCodeLibraryDir)**\*.pdb" />
        </ItemGroup>
        <Attrib Files="@(PdbFilesToDelete)" ReadOnly="false" />
        <Delete Files="@(PdbFilesToDelete)">
            <!-- <Delete Files="$(UnityCodeLibraryDir)**\*.pdb" /> doesn't work as it isn't a list, ala ItemGroup? -->
            <Output ItemName="FilesDeleted" TaskParameter="DeletedFiles" />
        </Delete>
        <Message Text="FilesDeleted: $(NewLine)@(FilesDeleted, '$(NewLine)')" Importance="high"/>
    </Target>

    <!-- TODO Confirm that the Mono Debug Environment has all the projects it needs -->
    <Target Name="_ConfirmDebugEnvReadiness" >
        <Message Text="WARNING! Confirm MonoDebugger includes all non-Test projects." Importance="high" />
        <Message Text="Procedure for adding an Existing Project to the Debug Environment." Importance="high"/>
        <Message Text="     1. Use OpenWith to open UnityDebugEnv.sln with MonoD, NOT with VS." Importance="high"/>
        <Message Text="     2. Add appropriate, existing Project(s) that are not Tests." Importance="high"/>
        <Message Text="     3. Uncheck the Build checkbox found in Solution Properties for each Project." Importance="high"/>
    </Target>

    <!-- Launch Unity -->
    <Target Name="_LaunchUnity" >
        <PropertyGroup>
            <UnityProjectScenePath>$(UnityProjectDir)Assets\Scenes\MainLoadScene.unity</UnityProjectScenePath>
        </PropertyGroup>
        <!-- <Exec Command="$(UnityProjectScenePath)" /> Confirmed working. -->
        <Message Text="LaunchUnity called." Importance="high"/>
    </Target>

    <!-- Operator is prompted to manually launch and attach MonoD to Unity -->
    <Target Name="_PromptMonoDebuggerLaunch" >
        <Message Text="Launch and attach the MonoDebugger." Importance="high" />
    </Target>

    <!-- General approach to INCREMENTALLY copying files. Key is _DynamicallyFindFilesToCopy target must exit before 
    FilesToCopySetupAsExternalProperty new content is visible to _CopyFilesCore -->
    <!--
    <Target Name="_DynamicallyFindFilesToCopy">
        <ItemGroup>
            <FilesToCopySetupAsExternalItemGroup Include="UseBatchingToGenerateListOfFiles" />
        </ItemGroup>
    </Target>
    <Target Name="CopyFiles" DependsOnTargets="_DynamicallyFindFilesToCopy" >
        <CallTarget Targets="_CopyFilesCore" />
    </Target>
    <Target Name="_CopyFilesCore" Inputs="@(FilesToCopySetupAsExternalProperty)"
            Outputs="@(FilesToCopySetupAsExternalItemGroup->'$(DirToCopyTo)%(Filename)%(Extension)')" >
        <MakeDir Directories="$(DirToCopyTo)" Condition="!Exists('$(DirToCopyTo)')"/>
        <Copy SourceFiles="@(FilesToCopySetupAsExternalItemGroup)" DestinationFolder="$(DirToCopyTo)" OverwriteReadOnlyFiles="true" />
    </Target>
    -->

</Project>
